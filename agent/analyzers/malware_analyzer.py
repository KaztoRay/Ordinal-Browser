"""
악성코드 분석기
===============

JavaScript 코드의 악성 패턴 탐지, 난독화 점수 계산,
LLM 기반 행동 예측을 수행합니다.

탐지 패턴:
- eval/Function/setTimeout 문자열 인수
- document.write, 인코딩된 페이로드 (base64/hex)
- iframe 주입, 크립토마이닝 패턴
- 변수명 엔트로피, 문자열 인코딩 비율, 코드 밀도
"""

from __future__ import annotations

import base64
import logging
import math
import re
from collections import Counter
from typing import Optional

from agent.core.config import AgentConfig
from agent.core.agent import ThreatDetail, ThreatLevel, ThreatType

logger = logging.getLogger(__name__)


# ============================================================
# 악성 패턴 정의
# ============================================================

class MalwarePatterns:
    """JavaScript 악성 패턴 정규표현식 모음"""

    # eval() 사용 (문자열 인수)
    EVAL_STRING = re.compile(
        r'\beval\s*\(\s*(?:'
        r'["\'][^"\']*["\']'  # 직접 문자열
        r'|(?:atob|unescape|decodeURIComponent)\s*\('  # 디코딩 함수 래핑
        r'|(?:String\.fromCharCode)\s*\('  # 문자 코드 변환
        r')',
        re.IGNORECASE,
    )

    # Function 생성자 (동적 코드 실행)
    FUNCTION_CONSTRUCTOR = re.compile(
        r'\bnew\s+Function\s*\(\s*["\']',
        re.IGNORECASE,
    )

    # setTimeout/setInterval 문자열 인수 (동적 실행)
    TIMER_STRING = re.compile(
        r'\b(?:setTimeout|setInterval)\s*\(\s*["\']',
        re.IGNORECASE,
    )

    # document.write (DOM 조작)
    DOCUMENT_WRITE = re.compile(
        r'\bdocument\.write(?:ln)?\s*\(',
        re.IGNORECASE,
    )

    # Base64 인코딩된 페이로드
    BASE64_PAYLOAD = re.compile(
        r'(?:atob|btoa)\s*\(\s*["\']([A-Za-z0-9+/=]{20,})["\']',
    )

    # Hex 인코딩된 문자열 (\x 시퀀스)
    HEX_ENCODED = re.compile(
        r'(?:\\x[0-9a-fA-F]{2}){4,}',
    )

    # Unicode 인코딩된 문자열 (\u 시퀀스)
    UNICODE_ENCODED = re.compile(
        r'(?:\\u[0-9a-fA-F]{4}){3,}',
    )

    # iframe 주입
    IFRAME_INJECTION = re.compile(
        r'(?:createElement\s*\(\s*["\']iframe["\']'
        r'|\.innerHTML\s*(?:\+?=)\s*["\'].*?<iframe'
        r'|document\.write\s*\([^)]*<iframe)',
        re.IGNORECASE | re.DOTALL,
    )

    # 크립토마이닝 패턴
    CRYPTO_MINING = re.compile(
        r'(?:coinhive|cryptoloot|coin-?hive|jsecoin|webminer|'
        r'CryptoNight|cryptonight|minero|deepminer|'
        r'miner\.start|startMining|CoinImp|'
        r'WebAssembly\.instantiate.*(?:wasm|mining))',
        re.IGNORECASE,
    )

    # WebSocket을 통한 마이닝 통신
    MINING_WEBSOCKET = re.compile(
        r'new\s+WebSocket\s*\(\s*["\']wss?://[^"\']*(?:mine|pool|stratum)',
        re.IGNORECASE,
    )

    # 키로거 패턴
    KEYLOGGER = re.compile(
        r'(?:addEventListener\s*\(\s*["\']key(?:down|up|press)["\'].*'
        r'(?:XMLHttpRequest|fetch|navigator\.sendBeacon|new\s+Image))',
        re.IGNORECASE | re.DOTALL,
    )

    # 데이터 유출 패턴
    DATA_EXFIL = re.compile(
        r'(?:document\.cookie|localStorage|sessionStorage)'
        r'[^;]*(?:XMLHttpRequest|fetch|navigator\.sendBeacon|new\s+Image)',
        re.IGNORECASE | re.DOTALL,
    )

    # 난독화된 변수/함수명 (1~2자 또는 _0x 접두사)
    OBFUSCATED_NAMES = re.compile(
        r'\b(?:_0x[a-f0-9]+|[a-zA-Z_$][a-zA-Z0-9_$]{0,1})\b'
    )

    # String.fromCharCode 다수 사용
    CHAR_CODE_ABUSE = re.compile(
        r'String\.fromCharCode\s*\([0-9,\s]{10,}\)',
    )

    # 리다이렉트 패턴
    REDIRECT = re.compile(
        r'(?:window\.location|document\.location|location\.href|location\.replace)\s*=',
        re.IGNORECASE,
    )

    # 클립보드 접근
    CLIPBOARD_ACCESS = re.compile(
        r'(?:navigator\.clipboard|document\.execCommand\s*\(\s*["\'](?:copy|paste)["\'])',
        re.IGNORECASE,
    )


class MalwareAnalyzer:
    """
    JavaScript 악성코드 분석기

    패턴 매칭, 난독화 점수 계산, LLM 행동 예측을 통해
    악성 JavaScript를 탐지합니다.
    """

    def __init__(self, config: AgentConfig) -> None:
        """
        악성코드 분석기 초기화

        Args:
            config: 에이전트 전역 설정
        """
        self.config = config
        self._threshold = config.threats.malware_threshold
        self._patterns = MalwarePatterns()
        logger.debug("MalwareAnalyzer 초기화 완료")

    # ============================
    # 공개 분석 메서드
    # ============================

    async def analyze_script(self, code: str) -> Optional[ThreatDetail]:
        """
        JavaScript 코드 악성 여부 분석

        패턴 매칭과 난독화 점수를 결합하여 위협을 평가합니다.

        Args:
            code: JavaScript 소스 코드

        Returns:
            ThreatDetail 또는 None (안전한 경우)
        """
        if not code or not code.strip():
            return None

        # 패턴 매칭 결과 수집
        pattern_results = self._match_patterns(code)

        # 난독화 점수 계산
        obfuscation = self._calculate_obfuscation_score(code)

        # 종합 점수 계산
        pattern_score = self._calculate_pattern_score(pattern_results)
        combined_score = self._combine_scores(pattern_score, obfuscation["score"])

        if combined_score < self._threshold:
            return None

        threat_level = self._score_to_level(combined_score)

        # 탐지된 지표 수집
        indicators = self._collect_indicators(pattern_results, obfuscation)

        # 악성코드 유형 결정
        malware_type = self._determine_malware_type(pattern_results)

        return ThreatDetail(
            threat_type=ThreatType.MALWARE,
            threat_level=threat_level,
            confidence=combined_score,
            description=f"악성 JavaScript 탐지 — {malware_type} (점수: {combined_score:.2f})",
            indicators=indicators,
            metadata={
                "pattern_score": pattern_score,
                "obfuscation_score": obfuscation["score"],
                "malware_type": malware_type,
                "pattern_matches": {
                    k: v for k, v in pattern_results.items() if v > 0
                },
                "obfuscation_details": obfuscation,
            },
        )

    async def analyze_html(self, html_content: str) -> Optional[ThreatDetail]:
        """
        HTML 내 인라인 스크립트에서 악성코드 탐지

        <script> 태그 내부의 코드를 추출하여 분석합니다.

        Args:
            html_content: HTML 소스 코드

        Returns:
            ThreatDetail 또는 None (안전한 경우)
        """
        # 인라인 스크립트 추출
        scripts = re.findall(
            r'<script[^>]*>(.*?)</script>',
            html_content,
            re.DOTALL | re.IGNORECASE,
        )

        if not scripts:
            return None

        # 모든 인라인 스크립트를 하나로 합침
        combined_code = "\n".join(scripts)
        return await self.analyze_script(combined_code)

    # ============================
    # 패턴 매칭
    # ============================

    def _match_patterns(self, code: str) -> dict[str, int]:
        """
        모든 악성 패턴에 대해 매칭 수행

        Returns:
            패턴명 → 매칭 횟수 딕셔너리
        """
        results: dict[str, int] = {}

        # eval 문자열 인수
        results["eval_string"] = len(self._patterns.EVAL_STRING.findall(code))

        # Function 생성자
        results["function_constructor"] = len(
            self._patterns.FUNCTION_CONSTRUCTOR.findall(code)
        )

        # setTimeout/setInterval 문자열 인수
        results["timer_string"] = len(self._patterns.TIMER_STRING.findall(code))

        # document.write
        results["document_write"] = len(self._patterns.DOCUMENT_WRITE.findall(code))

        # Base64 페이로드
        base64_matches = self._patterns.BASE64_PAYLOAD.findall(code)
        results["base64_payload"] = len(base64_matches)
        # Base64 디코딩 시도하여 실행 코드 포함 확인
        results["base64_executable"] = sum(
            1 for b in base64_matches if self._is_executable_base64(b)
        )

        # Hex 인코딩
        results["hex_encoded"] = len(self._patterns.HEX_ENCODED.findall(code))

        # Unicode 인코딩
        results["unicode_encoded"] = len(self._patterns.UNICODE_ENCODED.findall(code))

        # iframe 주입
        results["iframe_injection"] = len(self._patterns.IFRAME_INJECTION.findall(code))

        # 크립토마이닝
        results["crypto_mining"] = len(self._patterns.CRYPTO_MINING.findall(code))

        # 마이닝 WebSocket
        results["mining_websocket"] = len(self._patterns.MINING_WEBSOCKET.findall(code))

        # 키로거
        results["keylogger"] = len(self._patterns.KEYLOGGER.findall(code))

        # 데이터 유출
        results["data_exfiltration"] = len(self._patterns.DATA_EXFIL.findall(code))

        # String.fromCharCode 남용
        results["charcode_abuse"] = len(self._patterns.CHAR_CODE_ABUSE.findall(code))

        # 리다이렉트
        results["redirect"] = len(self._patterns.REDIRECT.findall(code))

        # 클립보드 접근
        results["clipboard_access"] = len(self._patterns.CLIPBOARD_ACCESS.findall(code))

        return results

    def _is_executable_base64(self, encoded: str) -> bool:
        """Base64 디코딩 후 실행 가능한 코드 포함 여부 확인"""
        try:
            # 패딩 보정
            padding = 4 - len(encoded) % 4
            if padding != 4:
                encoded += "=" * padding
            decoded = base64.b64decode(encoded).decode("utf-8", errors="ignore")
            # 실행 가능한 JavaScript 키워드 검색
            exec_keywords = [
                "eval", "function", "document", "window",
                "script", "exec", "setTimeout", "setInterval",
            ]
            return any(kw in decoded.lower() for kw in exec_keywords)
        except Exception:
            return False

    # ============================
    # 난독화 점수 계산
    # ============================

    def _calculate_obfuscation_score(self, code: str) -> dict:
        """
        코드 난독화 점수 계산

        여러 지표를 종합하여 0.0~1.0 범위의 난독화 점수를 산출합니다.

        지표:
        - 변수명 엔트로피: 무의미한 변수명 탐지
        - 문자열 인코딩 비율: 인코딩된 문자열의 비율
        - 코드 밀도: 공백 대비 코드 밀도
        """
        details: dict = {}

        # 1. 변수명 엔트로피 계산
        var_names = self._extract_variable_names(code)
        var_entropy = self._names_entropy(var_names)
        details["variable_name_entropy"] = var_entropy
        details["variable_count"] = len(var_names)

        # 높은 엔트로피 = 난독화된 변수명 (0.0~1.0 정규화)
        entropy_score = min(1.0, var_entropy / 5.0) if var_entropy > 2.5 else 0.0

        # 2. 문자열 인코딩 비율
        total_strings = len(re.findall(r'["\'][^"\']{2,}["\']', code))
        encoded_strings = (
            len(self._patterns.HEX_ENCODED.findall(code))
            + len(self._patterns.UNICODE_ENCODED.findall(code))
            + len(self._patterns.BASE64_PAYLOAD.findall(code))
        )
        encoding_ratio = encoded_strings / max(total_strings, 1)
        details["string_encoding_ratio"] = encoding_ratio
        encoding_score = min(1.0, encoding_ratio * 2.0)

        # 3. 코드 밀도 (공백 제거 후 비율)
        stripped = code.replace(" ", "").replace("\n", "").replace("\t", "")
        code_density = len(stripped) / max(len(code), 1)
        details["code_density"] = code_density
        # 매우 높은 밀도 = 미니파이/난독화 (0.95 이상)
        density_score = max(0.0, (code_density - 0.85) / 0.15) if code_density > 0.85 else 0.0

        # 4. 평균 줄 길이 (난독화 코드는 매우 긴 줄)
        lines = code.split("\n")
        non_empty_lines = [ln for ln in lines if ln.strip()]
        avg_line_length = (
            sum(len(ln) for ln in non_empty_lines) / max(len(non_empty_lines), 1)
        )
        details["avg_line_length"] = avg_line_length
        line_score = min(1.0, max(0.0, (avg_line_length - 200) / 500))

        # 5. _0x 접두사 변수 비율
        hex_var_count = len(re.findall(r'\b_0x[a-f0-9]+\b', code))
        details["hex_var_count"] = hex_var_count
        hex_var_score = min(1.0, hex_var_count / 20.0)

        # 종합 점수 (가중 평균)
        combined = (
            entropy_score * 0.20
            + encoding_score * 0.25
            + density_score * 0.20
            + line_score * 0.15
            + hex_var_score * 0.20
        )
        details["score"] = min(1.0, max(0.0, combined))

        return details

    def _extract_variable_names(self, code: str) -> list[str]:
        """JavaScript 코드에서 변수명 추출"""
        # var, let, const 선언에서 변수명 추출
        var_pattern = re.compile(
            r'\b(?:var|let|const)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)'
        )
        # function 선언에서 함수명 추출
        func_pattern = re.compile(
            r'\bfunction\s+([a-zA-Z_$][a-zA-Z0-9_$]*)'
        )

        var_names = var_pattern.findall(code)
        func_names = func_pattern.findall(code)
        return var_names + func_names

    def _names_entropy(self, names: list[str]) -> float:
        """변수/함수명의 평균 문자 엔트로피 계산"""
        if not names:
            return 0.0

        entropies: list[float] = []
        for name in names:
            if len(name) < 2:
                continue
            counter = Counter(name.lower())
            length = len(name)
            entropy = -sum(
                (c / length) * math.log2(c / length)
                for c in counter.values()
                if c > 0
            )
            entropies.append(entropy)

        return sum(entropies) / max(len(entropies), 1)

    # ============================
    # 점수 계산
    # ============================

    def _calculate_pattern_score(self, results: dict[str, int]) -> float:
        """패턴 매칭 결과 기반 점수 계산"""
        score = 0.0

        # 가중치 매핑 (패턴명 → 기본 점수)
        weights: dict[str, float] = {
            "eval_string": 0.15,
            "function_constructor": 0.15,
            "timer_string": 0.10,
            "document_write": 0.08,
            "base64_payload": 0.10,
            "base64_executable": 0.25,
            "hex_encoded": 0.08,
            "unicode_encoded": 0.06,
            "iframe_injection": 0.20,
            "crypto_mining": 0.35,
            "mining_websocket": 0.30,
            "keylogger": 0.35,
            "data_exfiltration": 0.30,
            "charcode_abuse": 0.12,
            "redirect": 0.05,
            "clipboard_access": 0.10,
        }

        for pattern_name, count in results.items():
            if count > 0 and pattern_name in weights:
                # 첫 번째 매칭은 전체 가중치, 추가 매칭은 감쇠
                base = weights[pattern_name]
                additional = min(count - 1, 5) * base * 0.1
                score += base + additional

        return min(1.0, score)

    def _combine_scores(
        self, pattern_score: float, obfuscation_score: float
    ) -> float:
        """패턴 점수와 난독화 점수를 결합"""
        # 패턴 점수가 주요, 난독화가 보조 (가중 합)
        combined = pattern_score * 0.70 + obfuscation_score * 0.30

        # 난독화 + 패턴 모두 높으면 보너스 (시너지 효과)
        if pattern_score > 0.3 and obfuscation_score > 0.5:
            combined += 0.10

        return min(1.0, max(0.0, combined))

    # ============================
    # 악성코드 유형 결정
    # ============================

    def _determine_malware_type(self, pattern_results: dict[str, int]) -> str:
        """탐지된 패턴에 기반하여 악성코드 유형 결정"""
        if pattern_results.get("crypto_mining", 0) > 0 or \
           pattern_results.get("mining_websocket", 0) > 0:
            return "크립토마이너"

        if pattern_results.get("keylogger", 0) > 0:
            return "키로거"

        if pattern_results.get("data_exfiltration", 0) > 0:
            return "데이터 유출"

        if pattern_results.get("iframe_injection", 0) > 0:
            return "iframe 주입"

        if (pattern_results.get("eval_string", 0) > 0 or
                pattern_results.get("function_constructor", 0) > 0):
            return "동적 코드 실행"

        if (pattern_results.get("base64_executable", 0) > 0 or
                pattern_results.get("hex_encoded", 0) > 0):
            return "인코딩된 페이로드"

        return "일반 악성 스크립트"

    # ============================
    # 지표 수집
    # ============================

    def _collect_indicators(
        self, pattern_results: dict[str, int], obfuscation: dict
    ) -> list[str]:
        """탐지 지표 목록 수집"""
        indicators: list[str] = []

        # 패턴 매칭 지표
        pattern_labels: dict[str, str] = {
            "eval_string": "eval() 문자열 실행",
            "function_constructor": "Function 생성자 사용",
            "timer_string": "setTimeout/setInterval 문자열 실행",
            "document_write": "document.write() 사용",
            "base64_payload": "Base64 인코딩 페이로드",
            "base64_executable": "Base64 디코딩 후 실행 코드 포함",
            "hex_encoded": "Hex 인코딩 문자열",
            "unicode_encoded": "Unicode 인코딩 문자열",
            "iframe_injection": "iframe 동적 주입",
            "crypto_mining": "크립토마이닝 코드",
            "mining_websocket": "마이닝 WebSocket 통신",
            "keylogger": "키보드 입력 캡처 (키로거)",
            "data_exfiltration": "민감 데이터 외부 전송",
            "charcode_abuse": "String.fromCharCode 남용",
            "redirect": "동적 리다이렉트",
            "clipboard_access": "클립보드 접근",
        }

        for pattern_name, count in pattern_results.items():
            if count > 0 and pattern_name in pattern_labels:
                indicators.append(f"{pattern_labels[pattern_name]} ({count}회)")

        # 난독화 지표
        if obfuscation["score"] > 0.5:
            indicators.append(
                f"코드 난독화 탐지 (점수: {obfuscation['score']:.2f})"
            )
        if obfuscation.get("hex_var_count", 0) > 5:
            indicators.append(
                f"_0x 접두사 변수 {obfuscation['hex_var_count']}개"
            )
        if obfuscation.get("code_density", 0) > 0.95:
            indicators.append("매우 높은 코드 밀도 (미니파이/난독화)")

        return indicators

    # ============================
    # 유틸리티
    # ============================

    @staticmethod
    def _score_to_level(score: float) -> ThreatLevel:
        """점수를 위협 수준으로 변환"""
        if score >= 0.85:
            return ThreatLevel.CRITICAL
        elif score >= 0.7:
            return ThreatLevel.HIGH
        elif score >= 0.5:
            return ThreatLevel.MEDIUM
        elif score >= 0.3:
            return ThreatLevel.LOW
        return ThreatLevel.SAFE
